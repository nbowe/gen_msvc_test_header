#!/usr/bin/env python

from optparse import OptionParser
import os
import sys
import re
import subprocess
import uuid
import datetime

"""
Due to old problem in visual studio many test frameworks wont run tests from static libraries.
see http://social.msdn.microsoft.com/forums/en-US/vclanguage/thread/2aa2e1b7-6677-4986-99cc-62f463c94ef3
This program will generate a header file from a lib file, including the appropriate references.


   Copyright 2011 Nikolas Bowe
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
   limitations under the License.
"""


	
regexes = map(	re.compile ,[
				# GTest
				# TEST(MathTest, TwoPlusTwoEqualsFour) {
				# 	EXPECT_EQ(2 + 2, 4);
				# }
				# produces a symbol like the following (ctor for generated test class)
				# (note TEST_F also generates similar code)
				# "  27993A0 ??0MathTest_TwoPlusTwoEqualsFour_Test@@QAE@XZ"
				r".*(\?\?0.+_.+_Test@@QAE@XZ)",
				
				# TODO: add more test frameworks regexes
			])

def main():
	parser = OptionParser(
		description="Generates a header from a msvc static library to force a program to reference test cases.",
		epilog = " ".join(["When linking a static library into a program, msvc will not run static initializers",
			"for objects in the library unless they are in an obj file that gets linked into the main program.\n",
			"This causes many test frameworks to not run some (or all) tests that are in static libs.\n",
			"This currently generates headers for Google Test, but its easy to extend to other frameworks\n",
			"Requires dumpbin to be in your path",
			]),
		usage="usage: %prog lib header",
		version="%prog 1.0",
	)
	(options, args) = parser.parse_args()
	if len(args) != 2:
		parser.print_help()
		sys.exit(1)
	libfile = args[0]
	headerfile = args[1]
	generate_header_for_lib(headerfile, libfile)
	
def generate_header_for_lib(headerfile, libfile):
	(lines,_) = command(["dumpbin", "/linkermember:1", libfile])
	test_symbols = find_matches(lines, regexes)
	
	with open(headerfile, 'w') as f:
		header_guard = "generated_"+str(uuid.uuid4()).replace('-','_')
		time = datetime.datetime.now().isoformat()
		f.write("#ifndef "+header_guard + '\n')
		f.write("#define "+header_guard + '\n')
		f.write("// Generated by gen_msvc_test_header at " + time + "\n")
		f.write("// do not modify \n\n")
		for symbol in test_symbols:
			pragma_line = '#pragma comment(linker, "/include:' + symbol + '")'
			f.write(pragma_line + '\n')
		f.write("\n#endif // "+header_guard + '\n')

			
def find_matches(lines, regexes):
	""" returns the first matchs group 1 for each line. if a line does not match any regex it is skipped """
	def match(line):
		for r in regexes:
			m = r.match(line)
			if m:
				return m.group(1)
		return None
	matches = filter(None, map(match,lines))
	return matches

def command(cmd, input=None):
	""" easy function for runnin simple commands.
	quite like subprocess.communicate but doesnt require 2.7 (a lot of people still run 2.6 or even 2.5)
	"""
	p = subprocess.Popen(cmd, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
	(stdoutdata, stderrdata) = p.communicate(input=input)
	if p.returncode != 0:
			raise subprocess.CalledProcessError(p.returncode, cmd)
	stdout_lines = stdoutdata.split()
	stderr_lines = stderrdata.split()
	return (stdout_lines, stderr_lines)


def find_matches_test():
	# sample lines from dumpbin output. some matching GTests regex
	# I should really do a proper test suite but this is enough for now
	lines = ["  27993A0 ??0MathTest_TwoPlusTwoEqualsFour_Test@@QAE@XZ",
			"  27993A0 ??1MathTest_TwoPlusTwoEqualsFour_Test@@UAE@XZ",
			"  279A992 ??0FooTest@@QAE@XZ",
			"  279A992 ??0FooTest_test1_Test@@QAE@XZ",
			"  279A992 ??0FooTest_test2_Test@@QAE@XZ",
	]
	assert(find_matches(lines, regexes) == ["??0MathTest_TwoPlusTwoEqualsFour_Test@@QAE@XZ","??0FooTest_test1_Test@@QAE@XZ","??0FooTest_test2_Test@@QAE@XZ"])


find_matches_test()

if __name__ == "__main__":
	main()

